/***********************************************************************/
/*                                                                     */
/*  FILE        :ASC3100Y5.c                                           */
/*  DATE        :Wed, Feb 05, 2020                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/36064                                              */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
/************************************************************************/
/*                                                                     	*/
/*  FILE        :ASC3100C7.c                                           	*/
/*  DATE        :Fri, Jan 10, 2020                                     	*/
/*  DESCRIPTION :Main Program                                          	*/
/*  CPU TYPE    :H8/36064                                              	*/
/*                                                                     	*/
/*  This file is generated by Renesas Project Generator (Ver.4.16).    	*/
/*                                                                     	*/
/************************************************************************/

#include  	"iodefine.h"
#include 	<machine.h>

#define		BMAX	600
#define		RMAX 	32
#define		false		0
#define		true		1	
typedef unsigned char	byte;


#if 0				

#define		PDR1		0xFFD4			//ポートデータレジスタ1
#define		PDR2		0xFFD5			//ポートデータレジスタ2
#define		PDR3		0xFFD6			//ポートデータレジスタ3
#define		PDR5		0xFFD8			//ポートデータレジスタ5
#define		PDR6		0xFFD9			//ポートデータレジスタ6
#define		PDR7		0xFFDA			//ポートデータレジスタ7
#define		PDR8		0xFFDB			//ポートデータレジスタ8
#define		PDRB		0xFFDD			//ポートデータレジスタB				
						
#define		PMR1		0xFFE0			//ポートモードレジスタ1
#define		PMR5		0xFFE1			//ポートモードレジスタ5
#define		PMR3		0xFFE2			//ポートモードレジスタ3

#define		PCR1		0xFFE4			//ポートコントロールレジスタ1
#define		PCR2		0xFFE5			//ポートコントロールレジスタ2
#define		PCR3		0xFFE6			//ポートコントロールレジスタ3
#define		PCR5		0xFFE8			//ポートコントロールレジスタ5
#define		PCR6		0xFFE9			//ポートコントロールレジスタ6
#define		PCR7		0xFFEA			//ポートコントロールレジスタ7
#define		PCR8		0xFFEB			//ポートコントロールレジスタ						

#define		PUCR1		0xFFD0			//ポートプルアップコントロールレジスタ1
#define		PUCR5		0xFFD1			//ポートプルアップコントロールレジスタ5

#define		LSYSCR1		0xFFF0			//システムコントロールレジスタ1
#define		LSYSCR2		0xFFF1			//システムコントロールレジスタ2
#define		LMSTCR1		0xFFF9			//モジュールスタンバイコントロールレジスタ1 
#define		LMSTCR2		0xFFFA			//モジュールスタンバイコントロールレジスタ2 

/***********************************************************************************************************************/
/* Global variables and functions 
/***********************************************************************************************************************/
struct st_pdr8{
			unsigned char B7:1;
			unsigned char B6:1;
			unsigned char B5:1;
			unsigned char B4:1;
			unsigned char B3:1;
			unsigned char B2:1;
			unsigned char B1:1;
			unsigned char B0:1;
};

#define	pdr8 (*((volatile struct st_pdr8 *)0xFFDB))

#endif



volatile    unsigned 	char	data[BMAX];
volatile	unsigned 	short	index = 0;
volatile	unsigned 	char	busy = 0;
volatile	unsigned 	char	rxtemp = 0;

volatile	unsigned	short	count1=0;
volatile	unsigned	short	count2=	3600;		//* life counter

volatile	unsigned 	char	plusecount = 0x00;
volatile	unsigned	long	remdata;
volatile	unsigned	long	remdata_temp;
volatile	unsigned 	char	remflag = 0;

volatile	unsigned	char	priscaler =0;

						
unsigned 	char	dipaddr	= 0;
unsigned	char	dipmode	= 0;


unsigned	char	rxflg;
unsigned	char	rcvlrc;
unsigned 	char	commY	= true;
char				commP	= '\0';
char				commI	= '\0';

union	inidata{
	unsigned	char	all[224];
	unsigned	char	room[32][7];	// OUT1 - OUT14
};
union inidata pattern = {	0	};		//patternという名のinidata型の配列

#if	0
								0,0,0,0,0,0,0,	//00	テスト用
								0,0,0,0,0,0,0,	//01		
								0,0,0,0,0,0,0,	//02
								0,8,0,0,0,0,0,	//03
								0,0,2,0,0,0,0,	//04
								0,0,8,0,0,0,0,	//05
								0,0,0,2,0,0,0,	//06
								0,0,0,8,0,0,0,	//07
								0,0,0,0,2,0,0,	//08
								0,0,0,0,8,0,0,	//09
								0,0,0,0,0,2,0,	//0A
								0,0,0,0,0,8,0,	//0B
								0,0,0,0,0,0,2,	//0C
								0,0,0,0,0,0,8,	//0D
								0,0,0,0,0,0,0,	//0E
								0,0,0,0,0,0,0,	//0F
								0,0,0,0,0,0,0,	//10
								0,0,0,0,0,0,0,	//11
								0,0,0,0,0,0,0,	//12	
								0,0,0,0,0,0,0,	//13
								0,0,0,0,0,0,0,	//14
								0,0,0,0,0,0,0,	//15
								0,0,0,0,0,0,0,	//16	
								0,0,0,0,0,0,0,	//17
								1,0,0,0,0,0,0,	//18
								0,1,0,0,0,0,0,	//19
								0,0,1,0,0,0,0,	//1A
								0,0,0,1,0,0,0,	//1B	
								0,0,0,0,1,0,0,	//1C
								0,0,0,0,0,1,0,	//1D
								0,0,0,0,0,0,1,	//1E
								0,0,0,0,0,0,0	//1F
						};
					
#endif

struct	aschextable{
		char			num;
		unsigned char	hex;
}
const	aschextable[] =	{	'0',0x00,
							'1',0x01,
							'2',0x02,
							'3',0x03,
							'4',0x04,
							'5',0x05,
							'6',0x06,
							'7',0x07,
							'8',0x08,
							'9',0x09,
							'A',0x0a,
							'B',0x0b,
							'C',0x0c,
							'D',0x0d,
							'E',0x0e,
							'F',0x0f
						};
struct	hexasctable{
		unsigned char	hex;
		char			num;
}
const	hexasctable[] =	{	0x00,'0',
							0x01,'1',
							0x02,'2',
							0x03,'3',
							0x04,'4',
							0x05,'5',
							0x06,'6',
							0x07,'7',
							0x08,'8',
							0x09,'9',
							0x0a,'A',
							0x0b,'B',
							0x0c,'C',
							0x0d,'D',
							0x0e,'E',
							0x0f,'F'
						};
																				

byte					tbuff[12]; //* = {0x02,'F','F','i',0x03,0x6a,'\0'}; 	//*送信 Buff
byte    				rnum[RMAX]  =   { 0 };      //* 0 - 31 *
byte    				outp[16]    =   { 0 };		//* 最終的なOUT配列

unsigned char			sendwait;

union	charToshort{
	unsigned	char	ch[2];
	unsigned	short	sh;
};
union	charToshort	hc574data;				//* outPut
		//hc574data = 0;
	
/***********************************************************************************************************************/
/*   Prototype
/***********************************************************************************************************************/

//void	systemIni();

void			wdtClr(void);
unsigned char	dip8Read();
unsigned char	dip4Read();
void			parallelOut(unsigned short data);
void			testMode(void);
void			adjst(void);
unsigned short	inputData(void);
unsigned short	change(unsigned short ax);
void 			sci32Ini(void);
void 			sci30Ini(void);
void 			wait(unsigned long i);
void			timerZ0ini(void);
void			timerB1ini(void);
void			irqIni(void);
void			UART0_tx(char al);
void			UART0_tx_str(byte *str);
void			UART0_tx_num(unsigned char *str, unsigned short ax);
unsigned char   ascConv(char numb);
void			UART0_start(void);
void			UART0_stop(void);
byte    		kUnfold(byte *dest, byte *addr);
void    		convData(byte *dest, byte *addr, byte lim);
void			popEep(byte *addr);
void			changeBit(unsigned short *sdata,  byte *addr);
void    		inputArray(byte *addr);
void    		dataClr(byte *dest, byte lim);
void    		dataSet(byte *dest, int num );
void    		allOr(byte *dest, byte  *addr, byte lim);
void 			stxComm(void);
void			enqComm(void);

void			test_kUnfold(void);
unsigned char 	comPression(void);
unsigned char 	calcLrc(unsigned short num);
char			hexascConvert(unsigned char al);
void    		sortByasc(byte *addr);
void			waitSfa(void);

void			UART2_tx(char al);
void			testUART2_tx(char al);
void			testUART2_tx_str(char *str);
void			testUART2_tx_num(char *str, unsigned short ax);

unsigned char	aschexConvert(char al);
unsigned char	ascChk(void);
void			lifeChk(void);

void	TEST_tx(char al);
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/				
void main(void){
	
	//systemIni();
	
	/* IO init */
	IO.PMR1.BYTE	=	0x02;
	IO.PDR1.BYTE	=	0x00;
	IO.PCR2			=	0x05;
	IO.PDR2.BYTE	= 	0x00;
	IO.PMR3.BYTE	=	0x00;
	IO.PCR3			= 	0xFF;
	IO.PMR5.BYTE	= 	0x00;
	IO.PCR5			= 	0x1F;
	IO.PUCR5.BYTE	= 	0x00;
	IO.PDR5.BYTE	= 	0xFF;
	IO.PCR6			= 	0x04;
	IO.PDR6.BYTE	= 	0x00;
	IO.PCR7			= 	0x15;
	IO.PDR7.BYTE	= 	0x00;
	IO.PCR8			= 	0x00;
	IO.PDR8.BYTE	=	0x00;
	
	SYSCR1.BYTE		=	0x00;	
	SYSCR2.BYTE		=	0x00;
	
	MSTCR1.BYTE		=	0x48;					//#B'01001000:8,AL;*,IIC,SCI3,AD,WDT,*,TIMEV,*
	MSTCR2.BYTE		=	0x00;

	IO.PDR5.BIT.B0 	= 1;				//* CS1 OFF
	IO.PDR5.BIT.B1 	= 1;				//* CS2 OFF
	IO.PDR5.BIT.B2 	= 1;				//* CS3 OFF
	
	IO.PDR7.BIT.B0 	= 0;				//* EIA485 RE 
	
	sci30Ini();
	sci32Ini();
	timerZ0ini();
	timerB1ini();
	irqIni();
	set_ccr(0x00);
	
	testMode();//* 20200207 ok
	
	dipaddr= hexascConvert(dip8Read()& 0x0f);	//addrは15まで
	//dataClr(rnum,32);
	//hc574data.sh = 0;
	dataClr(outp,16);	//outpをclrした方が有効　outpからsdata作成され　sdataが出力されるから
	waitSfa();		
	
	
	
	/* Ｉ／Ｏの初期化 */
#if 0
	*(char *)PMR1	=	0x02;				//* 0b00000010
	*(char *)PDR1	= 	0x00;				//* 0b00000000
	*(char *)PCR2	=	0x05;				//* 0b00000101
	*(char *)PMR3	=	0x00;				//* 0b00000000
	*(char *)PDR2	= 	0x00;				//*
	*(char *)PCR3	= 	0xFF;				//* 
	*(char *)PMR5	= 	0x00;				//* 
	*(char *)PCR5	= 	0x1F;				//* 0b00011111
	*(char *)PUCR5	= 	0x00;				//*
	*(char *)PDR5	= 	0xFF;				//*
	*(char *)PCR6	= 	0x04;				//* 0b00000100
	*(char *)PDR6	= 	0x00;				//* 
	*(char *)PCR7	= 	0x15;				//*
	*(char *)PDR7	= 	0x00;				//*
	*(char *)PCR8	= 	0x00;				//*
	*(char *)PDR8	=	0x00;
	//* メイン（ＬＥＤ点灯） */
	//*(char *)0xffeb = 0x00;				/* ポート８を入力に設定 */
	//*(char *)0xffdb = 0x0f;				/* Ｐ８のＬＥＤが接続されたビットを１にする */
	//*(char *)0xffeb = 0x0f;				/* Ｐ８のＬＥＤが接続されたビットを出力に設定 */
#endif	
/***********************************************************************************************************************
* Function Name	: 
* Description  		: 
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
	while(1){								

		lifeChk();
		
		enqComm();	//* 20200206 ok
		stxComm();	//* stx受信 -> 電文_展開 -> allOr
		
		if(count1 == 0){
			count1= 8;							//*   50mS * 8 
			changeBit(&hc574data.sh, outp);		//*   outpからsdata作成
			parallelOut(hc574data.sh);
		}										
	}//* for while(1)


}//* for MAIN


#if 0
#pragma inline_asm adjst
void	adjst(){
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
	NOP;
}
#endif
/***********************************************************************************************************************
* Function Name	: 		Life CHK
* Description  		: 
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
void	lifeChk(void){
	
		if(count2==0){
			commY	= 	false;
			commP	= 	'\0';
			commI	= 	'\0';
			count2	=	1800;
		}	
}
/***********************************************************************************************************************
* Function Name	: 
* Description  		: nop() SLEEP()は<machine.h>にある
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
void	adjst(void){
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
		//sleep();
}
/***********************************************************************************************************************
* Function Name	: 
* Description  		: 
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
void sci30Ini(void){				//* 送信

	char al;
	SCI3.SCR3.BYTE = 0x00;			//* RESET
	//*SCI3.SMR.BYTE = 0x00;			//* CA,8bit,PE,O/E,STOP,MP,CKS1,CKS0
	SCI3.SMR.BYTE = 0x20;			//* EVEN
	SCI3.BRR = 23;					//* 19200bps	(at 14.745MHz)
	wait( 20 );						//* 54uS WAIT
	SCI3.SCR3.BYTE = 0x20;			//* TIE,RIE,TE,RE,MPIE,TEIE,CKE1,CKE0
	
	al = SCI3.SSR.BYTE;				//* 読捨て
	SCI3.SSR.BYTE = 0x80;			//* ERROR FLG CLR*/
	
	//SCI3.SCR3.BIT.RIE = 1;		//* 受信割り込みOK*/	
}

void sci32Ini(void){				//* 受信
	
	char al;
	SCI3_2.SCR3.BYTE = 0x00;		//* RESET
	//*SCI3_2.SMR.BYTE = 0x00;			//* CA,8bit,PE,O/E,STOP,MP,CKS1,CKS0
	SCI3_2.SMR.BYTE = 0x20;
	SCI3_2.BRR = 23;				//* 19200bps	(at 14.745MHz)
	wait( 20 );						//* 54uS WAIT
	SCI3_2.SCR3.BYTE = 0x30;		//* TIE,RIE,TE,RE,MPIE,TEIE,CKE1,CKE0
	
	al = SCI3_2.SSR.BYTE;			//* 読捨て 
	SCI3_2.SSR.BYTE = 0x80;			//* ERROR FLG CLR*/
	
	SCI3_2.SCR3.BIT.RIE = 1;		//* 受信割り込みOK*/	
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	sci32interrupt(void){
	
	byte	al;
		
	if((SCI3_2.SSR.BYTE & 0x38) == 0){
							
		if(SCI3_2.SSR.BIT.RDRF){
			
			SCI3_2.SSR.BIT.RDRF = 0;
			
			al = SCI3_2.RDR;
			
			if(al==0xfa || al==0x05) rxtemp = al;
			
			if(busy== 1) return;					//* busy後は入力させない

			data[index] = al;
			
			if(rxflg == 0x03){						//* 0x03受信後のLRCで受信完了"!"
				rxflg = '!';
				rcvlrc = data[index];
				busy = 1;						
			}
			if(data[index] == 0x02 && rxflg == 0){		//* 0x02受信
				rxflg = 0x02;
				index = 0;
				data[index] = 0x02;
			}
			if(data[index] == 0x03 && rxflg == 0x02){ //* 0x02 受信後の 0x03
				rxflg = 0x03;
			}
			if(data[index] == 0x05 && rxflg == 0){		//*ENQ受信
				rxflg = 0x05;
				index = 0;
				data[index] = 0x05;
			}
			if(rxflg== 0x05 && index== 2) rxflg= '?';	//* ENQ後 2BYTE
			
			if(++index > BMAX) index= 0;
		}
	}
	else{
		//UART0_tx(0x02);	TEST用
		
		SCI3_2.SSR.BIT.OER = 0;
		SCI3_2.SSR.BIT.FER = 0;
		SCI3_2.SSR.BIT.PER = 0;
		SCI3_2.SSR.BIT.RDRF = 0;
		rxtemp = SCI3_2.RDR;
	}		
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void enqComm(){
	
    if(rxflg=='?'){                        
		    			/* serComm()でrxFlg確定 */
		rxflg=	0;
        index=	0;
		
		if('D'==data[1] && dipaddr== data[2]){			//* addr
        	count2  =   1800;							//* 50mS * 1800 lifeCounter
			
			if(commY == false) return;			//* 参加許可前の返信禁止
			
			if('P'!= commP){
				commP='P';
				UART0_start();
				tbuff[0]= 0x02;
				tbuff[1]= 'F';
				tbuff[2]= 'F';
				tbuff[3]= 'p';				//* table DATA
				tbuff[4]= 0x03;
				tbuff[5]= 0x73;
				tbuff[6]= '\0';
				UART0_tx_str(tbuff); 
				UART0_stop();
				busy = 0;             	
			}
			else if('I'== commI){					//* I受信済
				UART0_start();	
            	UART0_tx(0x04);
				//*UART0_tx_num(pattern.all,256);//test用
				//*UART0_tx_num(rnum,32);          
            	UART0_stop();
			}         
			else{
				UART0_start();
				tbuff[0]= 0x02;
				tbuff[1]= 'F';
				tbuff[2]= 'F';
				tbuff[3]= 'i';				//* 状態要求
				tbuff[4]= 0x03;
				tbuff[5]= 0x6A;
				tbuff[6]= '\0';
				UART0_tx_str(tbuff); 
				UART0_stop(); 
			}                               
		}
    }    
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void stxComm(){
    
    byte	al;
	unsigned char ans;
    
    if(rxflg=='!'){
	
		rxflg = 0;
		
        if('D'!=data[1] || dipaddr!= data[2]){
			busy = 0; 
			return;
		}
        
		count2  =   1800;				//* 50mS * 1800
        
		if(data[3]=='Y'){               //* Y電文           
            
			commY   =   true;			//* Y電文受信後に許可される	
			busy = 0;             
        }
                    
        else if(data[3]=='V'){    			//*ASC3100もV電文のcommYはチェック無し  
			if(0x15== calcLrc(583)){
				UART0_start();
				UART0_tx(0x15);
				UART0_stop();
				busy = 0;
				return;
			}
			UART0_start();
			tbuff[0]= 0x02;
		  	tbuff[1]= 'F';
			tbuff[2]= 'F';
			tbuff[3]= 'x';
			tbuff[4]= '0';
			tbuff[5]= '0';
			tbuff[6]= 0x03;
			tbuff[7]= 0x7B;
			tbuff[8]= '\0';
			UART0_tx_str(tbuff);
			UART0_stop();
			busy =	0;
			commP=	'\0'; 
        }
        else if(data[3]=='P' /* && commY==true */){			//* P電文に Y許可が必要か？
			
			if(0x15== calcLrc(583) || 0x7f== ascChk()){		//* '0'-'F'
				UART0_start();
				UART0_tx(0x15);
				UART0_stop();
				busy = 0;
				return;
			}
			ans = (0x03== comPression())? 0x06: 0x15;		//* 16byte -> 8byteに圧縮				
			UART0_start();
            UART0_tx(ans);            
            UART0_stop();
			busy = 0;
			//* UART0_tx_num(pattern.all,224);					//* test			
		}
		
		else if(data[3]=='K' && commY==true){
			
			if(0x15== calcLrc(583)){
				UART0_start();
            	UART0_tx(0x15);								// ACK or NAK            
            	UART0_stop();
				busy = 0;
				return;
			}
	  		ans= kUnfold(rnum,data);     		// rnum[RMAX] にstatusが入る 0,1,2,0,0,0,data[indexEND]
			UART0_start();
            UART0_tx(ans);						// ACK or NAK            
            UART0_stop();
			busy = 0;

            if(ans == 0x06){
				popEep(rnum);
				commI= 'I';
			}
        }                                     
    }
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	parallelOut(unsigned short ax){
		
		         
		IO.PDR5.BIT.B3 	= 0;				// (active LOW) 74HC545 CLK
		IO.PDR3.BYTE	= (char)ax;
		IO.PDR5.BIT.B3 	= 1;				//* 74HC545 CLK
		ax	= ax >> 8;	
		IO.PDR5.BIT.B4 	= 0;				// (active LOW) 74HC545 CLK
		IO.PDR3.BYTE	= (char)ax;
		IO.PDR5.BIT.B4 	= 1;				//* 74HC545 CLK
	}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char	dip8Read(){
	
	unsigned char al = 0;
	while(AD.ADCSR.BIT.ADST != 0){
	}
	AD.ADCSR.BYTE = 0x00;
	IO.PDR5.BIT.B2 	= 0;			//CS3
	adjst();
	al	= IO.PDRB.BYTE;
	

	while(AD.ADCSR.BIT.ADST != 0){
	}			
	AD.ADCSR.BYTE	=	0x01;
	IO.PDR5.BIT.B2 	= 0;			//CS3
	adjst();
	al	= al | IO.PDRB.BYTE;
	
	IO.PDR5.BIT.B2 	= 1;			//CS3
	//return(~al & 0x3F);			???
	return(~al);
}
/***********************************************************************************************************************
* Function Name		: dip4Read() 
* Description  		: Dip4 
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
unsigned char	dip4Read(){
	
	unsigned char	al=0;
	
	al= IO.PDR6.BYTE;
	al= al >> 4;
	return (~al);	
}
/***********************************************************************************************************************
* Function Name	: 
* Description  		: Photocoupler --> 74HC541 
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
unsigned short	inputData(){
	
	//*unsigned	char	al= 0;
	//*unsigned 	short	ax= 0;
	union	charToshort	hc541data;				//* inPut
	
	hc541data.sh		= 0;
	
	while(AD.ADCSR.BIT.ADST != 0){
	}
	AD.ADCSR.BYTE = 0x00;			
	IO.PDR5.BIT.B1 	= 0;				//CS2 ON
	adjst();
	//al	= (~IO.PDRB.BYTE);
	hc541data.ch[0]	= IO.PDRB.BYTE;
	while(AD.ADCSR.BIT.ADST != 0){
	}
	AD.ADCSR.BYTE = 0x01;			
	adjst();
	//al |= (~IO.PDRB.BYTE);
	hc541data.ch[0]	|= IO.PDRB.BYTE;
	IO.PDR5.BIT.B1 	= 1;				//CS2 OFF
	
	//	ax |= al;
	
	//ax= ax << 8;
	
	while(AD.ADCSR.BIT.ADST != 0){
	}
	AD.ADCSR.BYTE = 0x00;			
	IO.PDR5.BIT.B0 	= 0;				//* CS1 ON
	adjst();
	//al	= (~IO.PDRB.BYTE);
	hc541data.ch[1]	= IO.PDRB.BYTE;
	while(AD.ADCSR.BIT.ADST != 0){
	}
	AD.ADCSR.BYTE = 0x01;			
	adjst();
	//al |= (~IO.PDRB.BYTE);
	hc541data.ch[1]	|= IO.PDRB.BYTE;
	IO.PDR5.BIT.B0 	= 1;				//* CS1 OFF
	
	//ax |= al;
	//return(ax);							//* 反転 
	return(hc541data.sh);
}
/***********************************************************************************************************************
* Function Name	:	 
* Description  		: 74HC541 --> 74HC574 並び変え （H/Wの都合）
* Arguments    		: Code
* Return Value 		: None
***********************************************************************************************************************/
unsigned short	change(unsigned short ax){
	
	unsigned short	bx= 0;
	
	(ax & 0x0001)&&(bx |= 0x0080);
	(ax & 0x0002)&&(bx |= 0x0040);
	(ax & 0x0004)&&(bx |= 0x0020);
	(ax & 0x0008)&&(bx |= 0x0010);
	
	(ax & 0x0010)&&(bx |= 0x0008);
	(ax & 0x0020)&&(bx |= 0x0004);
	(ax & 0x0040)&&(bx |= 0x0002);
	(ax & 0x0080)&&(bx |= 0x0001);

	
	(ax & 0x0100)&&(bx |= 0x8000);
	(ax & 0x0200)&&(bx |= 0x4000);
	(ax & 0x0400)&&(bx |= 0x2000);
	(ax & 0x0800)&&(bx |= 0x1000);
	
	(ax & 0x1000)&&(bx |= 0x0800);
	(ax & 0x2000)&&(bx |= 0x0400);
	(ax & 0x4000)&&(bx |= 0x0200);
	(ax & 0x8000)&&(bx |= 0x0100);
	return(bx);		
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void wait(unsigned long i){
	
	while(i--){
		wdtClr();
	}
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	wdtClr(void){
	
	WDT.TCSRWD.BYTE &= ~0x80;
	WDT.TCSRWD.BYTE	|= 0x40;
	WDT.TCWD = 0;
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	irqIni(void){
	
	IENR2.BIT.IENTB1	= 1;			//*#B'00100000;*,*,TIMERB1,*,*,*,*,*

}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	timerZ0ini(void){
	
	TZ0.TCR.BYTE 	= 0x2B;		//001,01,011TCNT CLR,↑EDGE,φ/8=1/14M*8=0.542uSEC
	TZ0.TIORA.BYTE	= 0x8C;		//1,000,1,100 1,GRB,1,GRA ↑EDGE
	TZ0.TIORC.BYTE	= 0x88;
	TZ0.TIER.BYTE	= 0xE1;		//1,1,1,OVIE,IMID,IMIC,IMIB,IMIA
	TZ.TMDR.BYTE	= 0X0E;		//BFD1,BFC1,BFD0,BFC0"EN",1,1,1,SYNC
	TZ.TSTR.BYTE	= 0XFD;		//1,1,1,1,1,1,STR1,STR0
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	timerB1ini(void){
	
	TB1.TMB1.BYTE 	= 0x80;		// auto,*,*,*,*,0,0,0(PSS=/8192)
	TB1.TLB1		= 166;		// 1/14.7456M*8192*89=49.99mSEC
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void timerZ0interrupt(void){
	
	unsigned char	al;
	
	if(TZ0.TSR.BIT.IMFA){
	
		if(TZ0.GRA > 4243 || TZ0.GRA < 1845){	//* 2.3m  1.0mS 
		
			plusecount = 0x00;
			remdata_temp = 0x00;
		
		}
		else{

			if (TZ0.GRA > 3328){				//* 1.75mS
	
				remdata_temp = remdata_temp | 1UL;
			}
			if ( plusecount >= 31){
	
				plusecount = 0x00;
				remdata = remdata_temp;
				remflag = 1;
			}
			else{
	
				plusecount++;
				remdata_temp = remdata_temp << 1;
				// IO.PDR7.BIT.B0	= !IO.PDR7.BIT.B0;
			}	
		}
		
		al	= TZ0.TSR.BYTE;
		TZ0.TSR.BIT.IMFA = 0;
	}		
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	timerB1interrupt(void){
	
		if(count1 != 0) count1--;
		if(count2 != 0) count2--;
		
		//*IO.PDR7.BIT.B0	= !IO.PDR7.BIT.B0;		//* TEST用
			
		IRR2.BIT.IRRTB1	= 0;
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char calcLrc(unsigned short num){
	
	unsigned char	al= 'D' ^ dipaddr; 
	unsigned short	i;
		
	for(i=3; i<=num; i++){					//* 全 dataは 582
		
		al^= data[i];						//* al = al ^ data[i];
		if(data[i]== 0x03) break;
	}
	if(i== num) return(0x15);
	return(data[++i]== al)? 0x06: 0x15;
}
/***********************************************************************************************************************
* Function Name: 
* Description  : out1 - out14 --> 1-7に圧縮
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char comPression(){
	
	unsigned char	al,bl,cl;
	unsigned short	i=4;		//data[3]= P
	
	
	for(i=4; i< 582; i++){		//* 3+576
			
		if(data[i]== 0x03) return(data[i]);
		
		al= ascConv(data[i]);
		if(al==0x7f) return(al);
		bl= ascConv(data[++i]);
		if(bl==0x7f) return(bl);
		
		al= (al<< 4)+ bl;						//* room 0x00 - 0x1F
		pattern.room[al][0]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//1-2 
		pattern.room[al][1]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//3-4
		pattern.room[al][2]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//5-6
		pattern.room[al][3]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//7-8
		pattern.room[al][4]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//9-10
		pattern.room[al][5]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//11-12
		pattern.room[al][6]= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);		//13-14
		cl= (data[++i]& 0x03)+((data[++i]& 0x03)<< 2);						//15-16 ダミー
	}	
}
/***********************************************************************************************************************
* Function Name: K_Unfold(k電文_展開)
* Description  : data[] -> rnum[] 	ETX迄回転
* Arguments    : data[0]
* Return Value : return(0x06)
***********************************************************************************************************************/
byte    kUnfold(byte *dest, byte *addr){

    unsigned	short		i= 3;				//* 0x02,0x30,0x31(端末addr)なので、3から
    byte    a   =	0;                        	//* addr
    byte    s   =	0;                        	//* status
    unsigned	short		j;
	
    for( j= 0; j< RMAX; j++){
        
        if(addr[i] == 'K'){
            a   = (ascConv(addr[++i]) << 4);		//* 部屋code
			a   = a | (0x0f & ascConv(addr[++i]));	//* 2byte -> HEX　例 0x02
          if(a > 0x1F) return(0x15);				//* RMAX 1F以上はない
            
			s   =   ascConv(addr[++i]);       		//*status -> HEX 0x00,0x01,0x02
          if(s > 0x02) return(0x15);				//* 0x03以上の設定は無い
            i++;
            dest[a] = s;                    		//* rmun[例0x02] <--  0とか1とかの部屋status buff
        }
        if(addr[i] == 0x03) return(0x06);
    }
    return(0x15);
}  
/***********************************************************************************************************************
* Function Name	: 
* Description  		: 
* Arguments    		: rnum[0]
* Return Value 		: None
***********************************************************************************************************************/
void    popEep(byte *addr){
	
	byte	buff[10];
	byte	temp[16];
	unsigned short	i;
	
	dataClr(outp, 16);             				//* outp[0]-[15] = 0
	
    for( i=0; i<RMAX; i++){
        
       if(addr[i] != 0){               			//rnum[]
      
            dataSet(buff, i );          		//* RAM pattern[i*7]-> buff[0]-buff[6]/buff[7]-buff[14]
			//*inputArray(buff);           		//* buff -> buff
			sortByasc(buff);
			convData(temp, buff, 8);  			//* buff[8] -> temp[16]			
			//UART0_tx_num(temp,16);				//*test  
			allOr(outp, temp, 16);				//* temp[16]  ||  outp[16] -> outp[16]
        }
    }
}       
/***********************************************************************************************************************
* Function Name	: 
* Description  		: RAM (pattern[])	から抜き出して　->	dest[]
* Arguments    		: None
* Return Value 		: None
***********************************************************************************************************************/
void	dataSet(byte *dest, int num ){      
		byte	i;
    	unsigned short	a = 7 * num;		//dataは *,*,*,*,*,*,*
 	
    	for( i=0; i< 7; i++){
        	dest[i] =   pattern.all[a++];
    	}    
}
/***********************************************************************************************************************
* Function Name	: 
* Description  		: Buff CLR		0 -> dest[i]
* Arguments    		: None
* Return Value 		: None
***********************************************************************************************************************/
void    dataClr(byte *dest, byte lim){
    byte	i;
    for( i=0; i< lim; i++){
        dest[i] = 0;
    }
}

/***********************************************************************************************************************
* Function Name: * conversion data Multiplex data *
* Description  : buff[8]->temp[16]  0x03はマスク
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
void    convData(byte *dest, byte *addr, byte lim){
	
#if 0	
	   dest[0]= (addr[0]>>2)&0x03;
	   dest[1]= addr[0]&0x03;
	   dest[2]= (addr[1]>>2)&0x03;
	   dest[3]= addr[1]&0x03;
	   dest[4]= (addr[2]>>2)&0x03;
	   dest[5]= addr[2]&0x03;
	   dest[6]= (addr[3]>>2)&0x03;
	   dest[7]= addr[3]&0x03;
	   dest[8]= (addr[4]>>2)&0x03;
	   dest[9]= addr[4]&0x03;
	   dest[10]= (addr[5]>>2)&0x03;
	   dest[11]= addr[5]&0x03;
	   dest[12]= (addr[6]>>2)&0x03;
	   dest[13]= addr[6]&0x03;
	   dest[14]= (addr[7]>>2)&0x03;
	   dest[15]= addr[7]&0x03;
#endif	 
	   
        while(lim--){                  			//* 12,34,56,78,910,1112,1213
            *dest++ = ((*addr) >> 2) & 0x03;
            *dest++ = *addr & 0x03;
			*addr++;          
        }
}
/***********************************************************************************************************************
* Function Name: sort by asc3100
* Description  : ASC3100の為の並ぶ替え
* Arguments    : (byte *dest ,byte  *addr ,byte lim)
* Return Value : None
***********************************************************************************************************************/
void    sortByasc(byte *addr){

		byte    a[4];
		
		a[0]     =	addr[0];          		
        a[1]     =	addr[1];					
        a[2]     =	addr[2]; 
        a[3]     =	addr[3];
		
		addr[0]	=	a[3];		// 3
		addr[1]	=	a[2];		// 2
		addr[2]	=	a[1];		// 1
		addr[3]	=	a[0];		// 0
		
		a[0]    =	addr[4];          		
        a[1]    =	addr[5];					
        a[2]    =	addr[6]; 
        a[3]    =	addr[7];
		 
		addr[4]	=	0x00;a[3];
		addr[5]	=	a[2];
		addr[6]	=	a[1];
		addr[7]	=	a[0];
}
/***********************************************************************************************************************
* Function Name: outp[16] or temp[16]
* Description  : 
* Arguments    : (byte *dest ,byte  *addr ,byte lim)
* Return Value : None
***********************************************************************************************************************/
void    allOr(byte *dest, byte  *addr, byte lim){
    byte	i;    
	for( i=0; i<lim; i++){
    	dest[i] =   dest[i] | addr[i];
    }   
}
/***********************************************************************************************************************
* Function Name: 
* Description  : temp[] から unsigned short dataを作成。
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
void		changeBit(unsigned short *sdata, byte *addr){
			
			unsigned short mask	= 0x0001;	
			unsigned char  index ;
	
//			if(count1 != 0) return;
//			count1 = 8;

			for(index= 0; index< 16; index++, mask= mask<< 1){
				switch(addr[index]){
					case		0x00:
						*sdata	=		*sdata	&	~mask;	
						break;
					case    	0x01:
                    	*sdata    =   *sdata    |   mask;
                    	break;
                	case    	0x02:                                   /* BLINK */
                    	*sdata    =   *sdata    ^   mask;           	/* EOR */
                    	break;     
                	case    	0x03:
                    	*sdata    =   *sdata    ^   mask;           	/* 3=EOR */
                    //seridata    =   seridata    &   ~mask;        	/* ONE SHOT CLR */ 
                    //addr[index] =   0x00;
                    	break;

                	default:
                    	*sdata    =   *sdata    &  ~mask;           	/*0,1,2,3以外は0 */
                    //seridata    =   seridata    |   mask;     		/* one shot */
                    //addr[index]--;                            		/* 0x05->0x04->0x03 この間0.8SEC */  
            	}
            	//mask  =mask    << 1;  for()に記入
        	}
}
/***********************************************************************************************************************
* Function Name: ArrayChange
* Description  : 
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
void    inputArray(byte *addr){
        
        volatile	byte    a[5];              
													
        a[0]     =addr[0];          		
        a[1]     =addr[1];					
        a[2]     =addr[2]; 
        a[3]     =addr[3];

        addr[0]     =a[2];
        addr[1]     =a[3];
        addr[2]     =a[0];
        addr[3]     =a[1];					//*a[3];      
        
        a[0]     =addr[4];
        a[1]     =addr[5];
        a[2]     =addr[6];
        a[3]     =addr[7];

        addr[4]     =a[2];
        addr[5]     =a[3];
        addr[6]     =a[0];
        addr[7]     =a[1];
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	UART0_tx(char al){
	
	while(SCI3.SSR.BIT.TDRE != 1){
	}
		SCI3.TDR	= al;	
}

void	TEST_tx(char al){
	
	while(SCI3.SSR.BIT.TDRE != 1){
	}
		SCI3.TDR	= al;	
}
/**********************************************************************/
void	UART2_tx(char	al){			//* test送信はSCI3_2
	
	while(SCI3_2.SSR.BIT.TDRE != 1){
	}
		SCI3_2.TDR	= al;	
}	
/**********************************************************************/
void	UART0_tx_str(byte *str){
	
	while(*str != '\0'){
		UART0_tx(*str++);
		//str++;
	}
}
void	testUART2_tx_str(char *str){
	
	while(*str != '\0'){
		UART2_tx(*str++);
	}
}
/**********************************************************************/
void	UART0_tx_num(unsigned char *str, unsigned short ax){
	
	while(ax--){
		UART0_tx(*str++);
		//str++;
	}
}
void	testUART2_tx_num(char *str, unsigned short ax){
	
	while(ax--){
		UART2_tx(*str++);
	}
}
/**********************************************************************/
void	UART0_start(void){
		wait( 1500 );																																													
		IO.PDR7.BIT.B0 = 1;
		wait( 300 );
}
/**********************************************************************/
void	UART0_stop(void){
		if(SCI3.SSR.BIT.TEND != 1){
		}
		wait( 400 );
		IO.PDR7.BIT.B0 = 0;
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	testtxd(void){
	if(count1   !=  0) return;
	
	count1	= 2;						//* 100m毎
	UART0_tx(0x05);
	
	//SCI3.TDR	= 0x55;					//* 送信はSCI3 受信はSCI3_2
}
/***********************************************************************************************************************
* Function Name: 
* Description  : ax=inputdata() >> bx=change(ax) >> parallelOut(bx)
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	testMode(void){
	
		unsigned long	axx= 2000;
		unsigned short	ax,cx= 0x0000;
		unsigned char	bx;
		
		while(dip4Read()& 0x01){
			
			bx= hexascConvert(dip8Read()& 0x0f);
			
			ax= (byte)dip8Read();					//* 1-8  dip8のチェック
			cx= (dip4Read() & 0x0f) << 8;			//* 9-12 dip4のチェック
			cx= ax + cx;

			(ax!=0x00)? parallelOut(change(cx)): parallelOut(~change(inputData()));
								
			//* parallelOut(~change(inputData()));		//* 50mS毎
			
			if(--axx == 0){
				axx = 20000;
				UART0_start();	
				UART0_tx(0x05);
				UART0_tx('D');
				UART0_tx(bx);
				UART0_stop();		
			}
			if(rxflg=='?' && 'D'==data[1]){
				rxflg = 0;
				axx= 1000;
			}
		}
}
 /***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	test_kUnfold(void){
		
		data[0]	=	0x02;
		data[1]	=	0x30;
		data[2]	=	0x30;
		data[3]	=	'K';				//* 0x4b
		data[4]	=	0x30;				//*
		data[5]	=	0x30;				//* room num
		data[6]	=	0x31;				//* status
		data[7]	=	'K';
		data[8]	=	0x30;
		data[9]	=	0x32;				//* roomnum
		data[10]	=	0x31;				//* status
		data[11]	=	0x03;
		
		if(0x06 == kUnfold(rnum,data)){
			//UART0_tx_num(rnum, 32);
			//UART0_tx(0x0D);
			//UART0_tx(0x0A);
			popEep(rnum);
		}
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	remMoni(){
		if(remflag){
			remflag	= 0;
			
			while(SCI3.SSR.BIT.TDRE == 0){// 待ち
			}
			SCI3.TDR = (char)remdata;
			
			remdata = remdata >> 8;
			while(SCI3.SSR.BIT.TDRE == 0){
			}
			SCI3.TDR = (char)remdata;
			
			remdata = remdata >> 8;
			while(SCI3.SSR.BIT.TDRE == 0){
			}
			SCI3.TDR = (char)remdata;
			
			remdata = remdata >> 8;
			while(SCI3.SSR.BIT.TDRE == 0){
			}
			SCI3.TDR = (char)remdata;
		}

}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char	ascChk(){
	
	unsigned short 	i = 4;					//* 0x02 D 0 P
	unsigned char	al;
	
	for(	; data[i]!=0x03 && i<582; i++){
		al= aschexConvert(data[i]);
		if(al==0x7f) break;					//* err = 0x7f
	}
	return al;
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char	ascConv(char numb){               
        
		if (0x2f< numb && numb< 0x3a){
            return(numb & 0x0F);            /* 00-09 */
        }
        if (0x40< numb && numb< 0x47){
            return(numb - 0x37);            /* 0A-0F */
        }
            return(0x7F);                   /* ERR */ 
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
unsigned char	aschexConvert(char al){
	
	unsigned char	i;
	unsigned char	bl	=	0x7f;			//* returnはHEXなのでERRは 0x7f
	
	for(i=0; i< 16; i++){
		
		if(aschextable[i].num == al){
			bl= aschextable[i].hex;
			break;
		}
	}
	return(bl);
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
char	hexascConvert(unsigned char al){
	
	unsigned char	i;
	unsigned char	bl	=	0;			//* returnはASCIIなのでERRは'\0'
	
	for(i=0; i< 16; i++){
		
		if(hexasctable[i].hex == al){
			bl= hexasctable[i].num;
			break;
		}
	}
	return(bl);
}
/***********************************************************************************************************************
* Function Name: 
* Description  : 
* Arguments    : Code
* Return Value : None
***********************************************************************************************************************/
void	waitSfa(){
	
	unsigned char	i;	
	//count2= dipaddr + 8;			//* 8= 400msec
	
	for(;;){						//* whileよりこれがいいらしい
		if(0xfa== rxtemp) return;	//* 誰かが出した
		if(0x05== rxtemp) break;	//* HOST生きた
	}
	
	UART0_start();
	for(i= 0; i<30; i++) UART0_tx(0xfa);
	UART0_stop();
}